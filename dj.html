<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>DCE • REQUESTS</title>
<style>
  :root{
    --bg:#212121;
    --section:#363636;
    --subsection:#424242;
    --border:#2b2b2b;
    --ink:#f2f2f2;
    --muted:#bdbdbd;

    --accent:#1dcec9;   /* Mark as Played */
    --amber:#f7b731;    /* Mark as Unplayed */
    --danger:#b22222;   /* Remove */
    --put:#d81b60;      /* Put Back */

    --radius:12px;
    --maxw:1100px;
  }

  @font-face{
    font-family:"Adventor";
    src:url("texgyreadventor-regular.otf") format("opentype");
    font-weight:400; font-style:normal; font-display:swap;
  }

  *{ box-sizing:border-box; }
  html,body{
    margin:0; background:var(--bg); color:var(--ink);
    font-family:"Adventor", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  }

  .wrap{ max-width:var(--maxw); margin:0 auto; padding:16px 14px 56px; }

  /* Header matching index.html */
  .dce-logo{ text-align:center; margin:14px 0 6px; }
  .dce-logo img{ max-width:min(220px,60vw); height:auto; }
  .page-title{
    text-align:center;
    margin:0 auto 26px;
    letter-spacing:.06em;
    font-weight:800;
    font-size:clamp(22px,5.5vw,36px);
  }

  .panel{
    background:var(--section);
    border:1px solid var(--border);
    border-radius:var(--radius);
    padding:14px;
    margin-bottom:14px;
  }
  label{ display:block; font-size:14px; color:var(--muted); margin:0 0 6px; }
  select{
    height:46px; border-radius:12px; border:1px solid #3a3a3a;
    background:#2a2a2a; color:#fff; font-size:15px; padding:0 12px; width:100%;
  }

  /* Inline info row stays reserved (no layout shift) */
  .inline-row{
    display:flex; align-items:center; gap:10px;
    margin-top:8px; min-height:24px;
  }
  .inline-text{ font-size:14px; font-weight:600; }
  .inline-text.good{ color:#34d399; }
  .inline-text.bad{ color:#ef4444; }

  /* Progress bar (first load / event change) */
  .progress{
    position:relative; height:6px; flex:1 1 240px; max-width:360px;
    background:#2a2a2a; border-radius:999px; overflow:hidden; border:1px solid #333;
    display:none;
  }
  .progress.show{ display:block; }
  .progress::after{
    content:""; position:absolute; inset:0;
    background:linear-gradient(90deg, rgba(29,206,201,.15) 0%, rgba(29,206,201,.65) 50%, rgba(29,206,201,.15) 100%);
    transform:translateX(-100%); animation:bar 1.4s linear infinite;
  }
  @keyframes bar{ to{ transform:translateX(100%); } }

  /* Subtle polling spinner (no text) */
  .spin{
    margin-left:auto; width:18px; height:18px; border-radius:50%;
    border:2px solid rgba(255,255,255,.25); border-top-color:#bbb;
    animation:spin .9s linear infinite; display:none;
  }
  .spin.show{ display:inline-block; }
  @keyframes spin{ to{ transform:rotate(360deg);} }

  /* Tabs (folder style) */
  .tabs-bar{
    display:flex; align-items:flex-end; gap:0; border-bottom:1px solid var(--border); padding:0 6px; margin-bottom:10px;
  }
  .tab-btn{
    height:36px; padding:0 14px; font-size:13px; color:#fff;
    background:#2f2f2f; border:1px solid var(--border); border-bottom:none;
    border-top-left-radius:10px; border-top-right-radius:10px;
    margin:0 6px; transform:translateY(1px); cursor:pointer;
  }
  .tab-btn.active{ background:var(--subsection); transform:translateY(0); }
  .hidden{ display:none!important; }

  /* Collapsibles */
  .collapsible{ background:var(--subsection); border:1px solid var(--border); border-radius:12px; padding:10px; margin-top:10px; }
  .collapsible-header{ display:flex; align-items:center; justify-content:space-between; cursor:pointer; user-select:none; }
  .twist{ width:18px; height:18px; display:grid; place-items:center; margin-left:8px; }
  .collapsible-body{ display:none; margin-top:10px; }
  .collapsible.open .collapsible-body{ display:block; }
  .count-pill{ font-size:13px; color:#dcdcdc; opacity:.9; margin-left:8px; }

  .list{ display:grid; gap:10px; }

  .card{
    background:var(--section);
    border:1px solid var(--border);
    border-radius:12px;
    padding:10px;
    display:grid;
    grid-template-columns:64px 1fr 190px;
    gap:12px;
    /* Pin children to the TOP so art/buttons don't recenter on expand */
    align-items:start;
  }
  .card.appear{ opacity:0; transform:translateY(8px); }
  .card.appear.card-ready{ transition:opacity .28s ease, transform .28s ease; opacity:1; transform:none; }
  .no-anim *{ transition:none!important; }

  @media (max-width:760px){ .card{ grid-template-columns:64px 1fr; } .card .actions{ grid-column:1/-1; } }

  .thumb{ width:64px;height:64px;border-radius:10px;background:#1f1f1f;object-fit:cover;display:block; align-self:start; }
  .meta{ min-width:0; }
  .title{ margin:0 0 2px; font-weight:800; font-size:16px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; color:#fff; }
  .sub{ margin:0; color:#e6e6e6; font-size:13px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }

  .reqline{ display:flex; align-items:center; gap:10px; margin-top:2px; cursor:pointer; user-select:none; }
  .reqline .car{ font-size:18px; line-height:1; font-weight:800; color:#eaeaea; }
  .reqline .txt{ font-size:14px; color:#eaeaea; font-weight:700; }
  .names-box{ margin-top:6px; background:var(--subsection); border:1px solid var(--border); border-radius:10px; padding:8px 10px; display:none; }
  .names-box.open{ display:block; }
  .names-box .hdr{ color:#cfcfcf; font-size:13px; margin:0 0 4px; }
  .names-box ul{ margin:0; padding-left:18px; }
  .names-box li{ margin:3px 0; color:#fafafa; font-size:13px; }

  .actions{ display:grid; gap:6px; align-self:start; }
  .btn{
    display:inline-flex; align-items:center; justify-content:center;
    padding:0 10px; height:30px; font-size:12px; line-height:1;
    border-radius:8px; border:1px solid transparent; cursor:pointer;
    box-shadow:0 2px 0 rgba(0,0,0,.35), 0 8px 14px rgba(0,0,0,.15);
    width:82%; margin:0 auto;
  }
  .btn:hover{ filter:brightness(1.05); }
  .btn.played{   background:var(--accent); border-color:var(--accent); color:#000; }
  .btn.unplayed{ background:var(--amber);  border-color:var(--amber);  color:#000; }
  .btn.remove{   background:var(--danger); border-color:var(--danger); color:#fff; }
  .btn.putback{  background:var(--put);    border-color:var(--put);    color:#fff; }
  .btn[disabled]{ opacity:.7; cursor:not-allowed; }

  .footer-line{ margin-top:10px; color:#fff; font-size:12px; }
</style>
</head>
<body>
  <div class="wrap">
    <!-- Centered logo -->
    <div class="dce-logo">
      <img src="assets/dce-logo.png" alt="David Charles Events" onerror="this.style.display='none'">
    </div>
    <div class="page-title">REQUESTS</div>

    <div class="panel">
      <label for="eventSel">Select Your Event</label>
      <select id="eventSel"></select>

      <!-- Inline info row (reserved height) -->
      <div class="inline-row">
        <span id="inlineText" class="inline-text"></span>
        <div id="inlineProgress" class="progress"></div>
        <span id="inlineSpin" class="spin" aria-hidden="true"></span>
      </div>
    </div>

    <div class="panel">
      <div class="tabs-bar">
        <button id="tabRequests" class="tab-btn active" type="button">Requests</button>
        <button id="tabSpam" class="tab-btn" type="button">Spam</button>
      </div>

      <div id="tabRequestsPane">
        <div class="collapsible open" id="reqWrap">
          <div class="collapsible-header" data-target="reqBody">
            <div>Requests <span id="reqCount" class="count-pill">(0)</span></div>
            <div class="twist">▾</div>
          </div>
          <div id="reqBody" class="collapsible-body">
            <div id="reqList" class="list"></div>
          </div>
        </div>

        <div class="collapsible" id="playedWrap">
          <div class="collapsible-header" data-target="playedBody">
            <div>Played Songs <span id="playedCount" class="count-pill">(0)</span></div>
            <div class="twist">▸</div>
          </div>
          <div id="playedBody" class="collapsible-body">
            <div id="playedList" class="list"></div>
          </div>
        </div>

        <div class="collapsible" id="removedWrap">
          <div class="collapsible-header" data-target="removedBody">
            <div>Removed Songs <span id="removedCount" class="count-pill">(0)</span></div>
            <div class="twist">▸</div>
          </div>
          <div id="removedBody" class="collapsible-body">
            <div id="removedList" class="list"></div>
          </div>
        </div>

        <div class="footer-line" id="statusLine"></div>
      </div>

      <div id="tabSpamPane" class="hidden">
        <div style="margin:6px 0 10px; font-size:18px; font-weight:800;">
          Spammed Requests <span id="spamCountTop" class="count-pill">(0)</span>
        </div>
        <div id="spamList" class="list"></div>
      </div>
    </div>
  </div>

<script>
/* ===== Config ===== */
const ENDPOINT_URL = 'https://script.google.com/macros/s/AKfycbzwibHxSCqYq3XGqDjdvHTeFmA-0A0giMozaFPLPyQ7dbWgUdyGy5K_TlJ7IjKg2NzBSg/exec';
const POLL_MS = 5000;

/* Render/poll control */
const ACTION_RENDER_LOCK_MS = 1200;
const ACTION_POLL_PAUSE_MS  = 1500;
const BUCKET_HOLD_MS        = 2500;
let renderLockUntil = 0;
let pollTimer = null;
let pollPausedUntil = 0;
function lockRender(){ renderLockUntil = Date.now() + ACTION_RENDER_LOCK_MS; }
function canRender(){ return Date.now() >= renderLockUntil; }
function pausePolling(){ pollPausedUntil = Date.now() + ACTION_POLL_PAUSE_MS; stopPolling(); setTimeout(()=>{ if(Date.now()>=pollPausedUntil) startPolling(); }, ACTION_POLL_PAUSE_MS); }

/* ===== Elements ===== */
const $ = s => document.querySelector(s);
const eventSel=$('#eventSel');

const inlineText=$('#inlineText');
const inlineProgress=$('#inlineProgress');
const inlineSpin=$('#inlineSpin');

const tabRequestsBtn=$('#tabRequests'), tabSpamBtn=$('#tabSpam');
const tabRequestsPane=$('#tabRequestsPane'), tabSpamPane=$('#tabSpamPane');

const reqList=$('#reqList'), playedList=$('#playedList'), removedList=$('#removedList'), spamList=$('#spamList');
const reqCountEl=$('#reqCount'), playedCountEl=$('#playedCount'), removedCountEl=$('#removedCount'), spamCountTop=$('#spamCountTop');
const statusLine=$('#statusLine');

/* ===== State ===== */
let currentCode='';
let rowsCache=[];
const removedKeySet=new Set();
const artCache=new Map();

const inFlightByKey = new Map();
const bucketHoldByKey = new Map();

let initialRequestsLoaded = false; // controls bar vs spinner

/* ===== Inline UI helpers ===== */
function showFullLoading(msg='Loading your requests...'){
  inlineText.textContent = msg;
  inlineText.classList.remove('bad');
  inlineText.classList.add('good');
  inlineProgress.classList.add('show');
  inlineSpin.classList.remove('show');
}
function showSpinnerOnly(){
  inlineText.textContent = '';
  inlineText.classList.remove('good','bad');
  inlineProgress.classList.remove('show');
  inlineSpin.classList.add('show');
}
function clearInline(){
  inlineText.textContent = '';
  inlineText.classList.remove('good','bad');
  inlineProgress.classList.remove('show');
  inlineSpin.classList.remove('show');
}
function showEventsError(){
  inlineText.textContent = 'Could not load events.';
  inlineText.classList.remove('good');
  inlineText.classList.add('bad');
  inlineProgress.classList.remove('show');
  inlineSpin.classList.remove('show');
}

/* ===== Utils ===== */
function parseEventDate(dateStr){
  const s = String(dateStr || '').trim();
  if (!s) return new Date(NaN);

  // YYYY-MM-DD -> local midnight
  if (/^\d{4}-\d{2}-\d{2}$/.test(s)){
    const [y,m,d] = s.split('-').map(Number);
    return new Date(y, m-1, d);
  }
  return new Date(s);
}

function pad2(n){return String(n).padStart(2,'0');}
function dow3(n){return ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][n]||'';}
function formatHeaderDate(s){ const d=parseEventDate(s); if(isNaN(d))return''; return `${dow3(d.getDay())} ${pad2(d.getMonth()+1)}.${pad2(d.getDate())}.${String(d.getFullYear()).slice(-2)}`;}
function keySong(song,artist){ return `${(song||'').toLowerCase()}|${(artist||'').toLowerCase()}`;}
function escapeHTML(s){ return String(s||'').replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

/* JSONP */
function jsonp(url,params={}){ const qs=new URLSearchParams(params); const cb='cb_'+Math.random().toString(36).slice(2); qs.set('callback',cb); qs.set('t',Date.now());
  return new Promise((res,rej)=>{ const s=document.createElement('script'); s.src=url+(url.includes('?')?'&':'?')+qs.toString();
    const kill=setTimeout(()=>{cleanup(); rej(new Error('timeout'));},9000);
    function cleanup(){clearTimeout(kill); try{delete window[cb];}catch{} s.remove();}
    window[cb]=(d)=>{cleanup(); res(d);}; s.onerror=()=>{cleanup(); rej(new Error('jsonp'));}; document.body.appendChild(s);
  });
}

/* Artwork */
async function getArtwork(song,artist){
  const k=keySong(song,artist); if(artCache.has(k)) return artCache.get(k);
  try{ const data=await jsonp('https://itunes.apple.com/search',{term:`${song} ${artist}`.trim(),entity:'musicTrack',limit:1});
    const url=data?.results?.[0]?.artworkUrl100||data?.results?.[0]?.artworkUrl60||''; artCache.set(k,url||''); return url||'';
  }catch{ artCache.set(k,''); return ''; }
}

/* Events */
async function loadActiveEvents(){
  showFullLoading('Loading your events...');
  try{
    const r=await jsonp(ENDPOINT_URL,{mode:'listActive'}); const list=Array.isArray(r?.events)?r.events:[];
    list.sort((a,b)=>parseEventDate(a.date||0)-parseEventDate(b.date||0));
    eventSel.innerHTML='';
    if(!list.length){ const opt=document.createElement('option'); opt.value=''; opt.textContent='No active events'; eventSel.appendChild(opt); currentCode=''; showEventsError(); return; }
    for(const ev of list){
      const opt=document.createElement('option'); opt.value=ev.code;
      const d=formatHeaderDate(ev.date); opt.textContent=d?`${d} - ${ev.name}`:(ev.name||ev.code);
      eventSel.appendChild(opt);
    }
    const pre=(new URLSearchParams(location.search).get('event')||'').trim();
    if(pre&&[...eventSel.options].some(o=>o.value===pre)) eventSel.value=pre;
    currentCode=eventSel.value||'';
    clearInline();
  }catch{ showEventsError(); }
}

/* Polling */
function startPolling(){ stopPolling(); pollTimer=setInterval(()=>fetchRows({background:true}), POLL_MS); }
function stopPolling(){ if(pollTimer) clearInterval(pollTimer); pollTimer=null; }

async function fetchRows({background=false} = {}){
  if(!currentCode) return;
  if(Date.now() < pollPausedUntil) return;

  if (!initialRequestsLoaded || !background) showFullLoading('Loading your requests...');
  else showSpinnerOnly();

  try{
    const r=await jsonp(ENDPOINT_URL,{mode:'read',event:currentCode});
    const raw = Array.isArray(r?.rows)?r.rows:[];
    rowsCache = raw.map(x=>({...x}));
    if (canRender()) renderAll(rowsCache);
    initialRequestsLoaded = true;
  }catch{
    statusLine.textContent='Connection error.';
  } finally{
    if (!background) clearInline();
    else inlineSpin.classList.remove('show');
  }
}

/* Build structures */
function splitBuckets(rows){
  const bySong=new Map(), playedGroups=new Map(), spamMap=new Map();
  const now = Date.now();

  for(const row of rows){
    const song=row.song_title||row.song||''; const artist=row.artist||''; const k=keySong(song,artist);

    if(inFlightByKey.has(k)){
      const {target}=inFlightByKey.get(k);
      row.played = target;
    }

    if(!row.played && !removedKeySet.has(k)){
      let g=bySong.get(k); if(!g){ g={key:k,song,artist,ids:[],names:new Set()}; bySong.set(k,g); }
      g.ids.push(row.id); if(row.name) g.names.add(row.name);
    }
    if(row.played){
      let pg=playedGroups.get(k); if(!pg){ pg={key:k,song,artist,ids:[],names:new Set()}; playedGroups.set(k,pg); }
      pg.ids.push(row.id); if(row.name) pg.names.add(row.name);
    }
    const kp=`${k}|${(row.name||'').toLowerCase()}`; spamMap.set(kp,(spamMap.get(kp)||0)+1);
  }

  let requests=[...bySong.values()].map(g=>({ key:g.key, song:g.song, artist:g.artist, ids:g.ids, people:[...g.names] }));
  let played  =[...playedGroups.values()].map(g=>({ key:g.key, song:g.song, artist:g.artist, ids:g.ids, people:[...g.names] }));

  if (bucketHoldByKey.size){
    const pinTo = (arrFrom, arrTo, keySetToPin) => {
      for (const key of keySetToPin){
        const idx = arrFrom.findIndex(x=>x.key===key);
        if (idx>=0) arrFrom.splice(idx,1);
      }
      for (const key of keySetToPin){
        if (!arrTo.some(x=>x.key===key)) {
          const any = rows.find(r=> keySong(r.song_title||r.song,r.artist)===key);
          if (any){
            const ids = rows.filter(r=> keySong(r.song_title||r.song,r.artist)===key).map(r=>r.id);
            const names=[...new Set(rows.filter(r=> keySong(r.song_title||r.song,r.artist)===key).map(r=>r.name).filter(Boolean))];
            arrTo.push({ key, song:any.song_title||any.song, artist:any.artist, ids, people:names });
          }
        }
      }
    };

    const toRequests=new Set(), toPlayed=new Set();
    for (const [k,hold] of bucketHoldByKey.entries()){
      if (now > hold.until){ bucketHoldByKey.delete(k); continue; }
      if (hold.bucket==='requests') toRequests.add(k);
      else if (hold.bucket==='played') toPlayed.add(k);
    }
    if (toRequests.size) pinTo(played, requests, toRequests);
    if (toPlayed.size)   pinTo(requests, played, toPlayed);
  }

  const removed=[];
  for(const rk of removedKeySet){
    const rel=rows.filter(r=> keySong(r.song_title||r.song,r.artist)===rk && !r.played);
    if(rel.length){
      const names=[...new Set(rel.map(r=>r.name).filter(Boolean))];
      const base=rel[0]; removed.push({ key:rk, song:base.song_title||base.song, artist:base.artist, ids:rel.map(r=>r.id), people:names });
    }
  }

  const spam=[];
  for(const [kp,count] of spamMap.entries()){
    if(count>1){
      const [songLower,artistLower,nameLower]=kp.split('|');
      const any=rows.find(x=> keySong(x.song_title||x.song,x.artist)===`${songLower}|${artistLower}` && String(x.name||'').toLowerCase()===nameLower );
      if(any){ spam.push({ song:any.song_title||any.song, artist:any.artist, name:any.name, count }); }
    }
  }

  return { requests, played, removed, spam };
}

/* Card helpers */
function namesBoxHTML(names){
  return `<div class="names-box"><p class="hdr">Requesters</p><ul>${names.map(n=>`<li>${escapeHTML(n)}`).join('')}</ul></div>`;
}
function buildCardBase(obj){
  const guests=obj.people.length;
  const el=document.createElement('div');
  el.className='card appear';
  el.dataset.key=obj.key;
  el.dataset.ids=JSON.stringify(obj.ids);
  el.innerHTML=`
    <img class="thumb" alt="">
    <div class="meta">
      <p class="title">${escapeHTML(obj.song||'Unknown Title')}</p>
      <p class="sub">${escapeHTML(obj.artist||'Unknown Artist')}</p>
      <div class="reqline"><span class="car">▸</span><span class="txt">Requested by ${guests} guest${guests===1?'':'s'}</span></div>
      ${namesBoxHTML(obj.people)}
    </div>
    <div class="actions"></div>
  `;
  getArtwork(obj.song,obj.artist).then(src=>{ if(src){ const img=el.querySelector('.thumb'); img.src=src; img.alt=`${obj.song} cover`; }});
  const box=el.querySelector('.names-box'); const reqline=el.querySelector('.reqline'); const car=reqline.querySelector('.car');
  reqline.addEventListener('click',()=>{ const open=box.classList.toggle('open'); car.textContent=open?'▾':'▸'; });
  requestAnimationFrame(()=> el.classList.add('card-ready'));
  return el;
}
function updateCardBase(node,obj){
  node.dataset.ids=JSON.stringify(obj.ids);
  node.querySelector('.title').textContent=obj.song||'Unknown Title';
  node.querySelector('.sub').textContent=obj.artist||'Unknown Artist';
  node.querySelector('.txt').textContent=`Requested by ${obj.people.length} guest${obj.people.length===1?'':'s'}`;
  node.querySelector('.names-box').innerHTML=`<p class="hdr">Requesters</p><ul>${obj.people.map(n=>`<li>${escapeHTML(n)}`).join('')}</ul>`;
}

/* Actions */
async function togglePlayedForKey(key, ids, targetPlayed){
  const now=Date.now();
  inFlightByKey.set(key,{target:targetPlayed, ts:now});
  bucketHoldByKey.set(key, { bucket: targetPlayed ? 'played' : 'requests', until: now + BUCKET_HOLD_MS });

  lockRender(); pausePolling();
  rowsCache = rowsCache.map(r => (ids.includes(r.id) ? {...r, played:targetPlayed} : r));
  renderAll(rowsCache);

  const card = document.querySelector(`[data-key="${CSS.escape(key)}"]`);
  if (card) card.querySelectorAll('.btn').forEach(b=> b.disabled = true);

  try{
    await Promise.all(ids.map(id => jsonp(ENDPOINT_URL,{mode:'setPlayed',id,played:String(targetPlayed)})));
  }catch{}

  const final = inFlightByKey.get(key);
  if (!final || final.ts !== now) return;

  if (card) card.querySelectorAll('.btn').forEach(b=> b.disabled = false);
  inFlightByKey.delete(key);
  await fetchRows({background:true});   /* spinner-only after actions */
}

function attachRequestActions(card){
  const actions=card.querySelector('.actions');
  actions.innerHTML=`
    <button class="btn played" type="button">Mark as Played</button>
    <button class="btn remove" type="button">Remove</button>
  `;
  actions.querySelector('.btn.played').addEventListener('click', ()=>{
    const ids=JSON.parse(card.dataset.ids||'[]'); const key=card.dataset.key;
    togglePlayedForKey(key, ids, true);
  });
  actions.querySelector('.btn.remove').addEventListener('click', ()=>{
    lockRender(); pausePolling();
    removedKeySet.add(card.dataset.key);
    renderAll(rowsCache);
  });
}
function attachPlayedActions(card){
  const actions=card.querySelector('.actions');
  actions.innerHTML=`
    <button class="btn unplayed" type="button">Mark as Unplayed</button>
  `;
  actions.querySelector('.btn.unplayed').addEventListener('click', ()=>{
    const ids=JSON.parse(card.dataset.ids||'[]'); const key=card.dataset.key;
    togglePlayedForKey(key, ids, false);
  });
}
function attachRemovedActions(card){
  const actions=card.querySelector('.actions');
  actions.innerHTML=`
    <button class="btn putback" type="button">Put Back</button>
  `;
  actions.querySelector('.btn.putback').addEventListener('click', ()=>{
    lockRender(); pausePolling();
    removedKeySet.delete(card.dataset.key);
    renderAll(rowsCache);
  });
}

/* Stable renderer */
function renderList(container, items, makeNode, updateNode){
  const existing = new Map();
  Array.from(container.children).forEach(ch=> existing.set(ch.dataset.key, ch));
  existing.forEach((node,key)=>{ if(!items.some(it=>it.key===key)) node.remove(); });

  container.classList.add('no-anim');

  let cursor = container.firstChild;
  for(const it of items){
    let node = existing.get(it.key);
    if(!node){
      node = makeNode(it);
      container.insertBefore(node, cursor || null);
    }else{
      updateNode(node,it);
      if(node !== cursor){
        container.insertBefore(node, cursor || null);
      }
    }
    cursor = node.nextSibling;
  }

  requestAnimationFrame(()=> container.classList.remove('no-anim'));
}

/* Build & render */
function renderAll(rows){
  const {requests, played, removed, spam}=splitBuckets(rows);

  const sortedReq=[...requests].sort((a,b)=> b.people.length - a.people.length || (a.song||'').localeCompare(b.song||''));
  renderList(reqList, sortedReq,
    (obj)=>{ const el=buildCardBase(obj); attachRequestActions(el); return el; },
    (node,obj)=> updateCardBase(node,obj)
  );

  const pg=[...played].sort((a,b)=>(a.song||'').localeCompare(b.song||''));
  renderList(playedList, pg,
    (obj)=>{ const el=buildCardBase(obj); attachPlayedActions(el); return el; },
    (node,obj)=> updateCardBase(node,obj)
  );

  renderList(removedList, removed,
    (obj)=>{ const el=buildCardBase(obj); attachRemovedActions(el); return el; },
    (node,obj)=> updateCardBase(node,obj)
  );

  spamList.innerHTML='';
  for(const s of spam){
    const el=document.createElement('div'); el.className='card';
    el.innerHTML=`
      <img class="thumb" alt="">
      <div class="meta">
        <p class="title">${escapeHTML(s.song||'Unknown Title')}</p>
        <p class="sub">${escapeHTML(s.artist||'Unknown Artist')}</p>
        <p class="sub">Requested by ${escapeHTML(s.name||'Guest')} (x${s.count})</p>
      </div>
      <div class="actions"></div>
    `;
    getArtwork(s.song,s.artist).then(src=>{ if(src){ el.querySelector('.thumb').src=src; }});
    spamList.appendChild(el);
  }

  reqCountEl.textContent    = `(${reqList.children.length})`;
  playedCountEl.textContent = `(${playedList.children.length})`;
  removedCountEl.textContent= `(${removedList.children.length})`;
  spamCountTop.textContent  = `(${spamList.children.length})`;
}

/* Collapsibles & tabs */
function initCollapsibles(){
  document.querySelectorAll('.collapsible-header').forEach(h=>{
    h.addEventListener('click',()=>{
      const p=h.parentElement; p.classList.toggle('open');
      const t=h.querySelector('.twist'); if(t) t.textContent=p.classList.contains('open')?'▾':'▸';
    });
  });
}
function setTab(which){
  if(which==='spam'){ tabSpamBtn.classList.add('active'); tabRequestsBtn.classList.remove('active'); tabSpamPane.classList.remove('hidden'); tabRequestsPane.classList.add('hidden'); }
  else{ tabRequestsBtn.classList.add('active'); tabSpamBtn.classList.remove('active'); tabRequestsPane.classList.remove('hidden'); tabSpamPane.classList.add('hidden'); }
}
tabRequestsBtn.addEventListener('click',()=>setTab('requests'));
tabSpamBtn.addEventListener('click',()=>setTab('spam'));

/* Init */
eventSel.addEventListener('change', async ()=>{
  currentCode=eventSel.value||''; removedKeySet.clear();
  initialRequestsLoaded = false;              // full-bar load on event change
  await fetchRows({background:false});        // show full text + bar
  startPolling();
});

(async function boot(){
  await loadActiveEvents();
  initCollapsibles();
  setTab('requests');
  if(eventSel.value){
    currentCode=eventSel.value;
    initialRequestsLoaded = false;
    await fetchRows({background:false});      // first load: full bar
    startPolling();                           // background polls: spinner only
  }
})();
</script>
</body>
</html>
